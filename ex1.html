<html>

<head>
    <link rel="stylesheet" href="style.css">

    <script type="text/javascript">
        const items = [
            { index: 0, text: "We few, we happy few, we band of brothers;" },
            { index: 1, text: "For he to-day that sheds his blood with me" },
            { index: 2, text: "Shall be my brother; be he ne'er so vile," },
            { index: 3, text: "This day shall gentle his condition;" },
            { index: 4, text: "And gentlemen in England now a-bed" },
            { index: 5, text: "Shall think themselves accurs'd they were not here," },
            { index: 6, text: "And hold their manhoods cheap whiles any speaks" },
            { index: 7, text: "That fought with us upon Saint Crispin's day." }
        ];

        function run() {
            var node = document.getElementById("content");
            while (node.firstChild) {
                node.removeChild(node.firstChild);
            }

            node = document.createElement('p');
            node.setAttribute("class", "line");
            var textNode = document.createTextNode("setting up callbacks...");
            node.appendChild(textNode);
            document.getElementById("content").appendChild(node);

            for (var i = 0; i < items.length; i++) {
                doAsynchOperation(items[i], doOutput)
            }

            node = document.createElement('p');
            node.setAttribute("class", "line");
            textNode = document.createTextNode("setting up callbacks... done");
            node.appendChild(textNode);
            document.getElementById("content").appendChild(node);
        }

        function doAsynchOperation(item, cb) {
            setTimeout(() => {
                var words = item.text.split(" ");
                words[words.length - 1] = words[words.length - 1].toUpperCase();
                var obj = { text: words.join(" ") };
                item = Object.assign({}, item, obj);
                cb(item);
            }, Math.random() * 1500);
        }

        function doOutput(item) {
            const node = document.createElement('p');
            node.setAttribute("class", "line");
            const textNode = document.createTextNode(item.text);
            node.appendChild(textNode);
            document.getElementById("content").appendChild(node);
        }
    </script>
</head>

<body>
    <div id="banner">
        <h1>Asynchronous operations in JavaScript</h1>
        <h2>Callbacks and the callback queue, part 1</h2>
        <span>This example shows that the results of asynchronous operations are unordered.</span> <a href="#" class="button" onclick="run()">Run</a>        
    </div>
    <div id="wrapper">
        <div id="text">
            <p>Calls to asynchronous operations are placed in a special area called the callback queue, and run only
                when
                our current function has completed. The callback queue works together with the <a
                    href="https://www.youtube.com/watch?v=8aGhZQkoFbQ">event loop</a> to execute your callback once the
                thread is available.
            </p>

            <p>
                Because JavaScript is single-threaded, as long as the current function ("run") is occupying the call
                stack,
                the underlying thread is not available
                to run any of the callbacks. When the callbacks do run, their run order is undefined.
            </p>

            <p>
                In this example we output each verse through a call to an asynchronous function (we use setTimeout() to
                achieve this; a more realistic example might be a file system operation, which are usually
                asynchronous).
                Each callback is invoked after a delay of at least 300 ms, and returns the verse with the last word
                uppercased.
            </p>

            <ul>
                <li>Callbacks cannot execute until the current function has completed</li>
                <li>Callbacks can execute in any order</li>
            </ul>

            <button class="collapsible">Code</button>
            <div class="content">
                    <div class="pre">
const items = [
    { index: 0, text: "We few, we happy few, we band of brothers;" },
    { index: 1, text: "For he to-day that sheds his blood with me" },
    { index: 2, text: "Shall be my brother; be he ne'er so vile," },
    { index: 3, text: "This day shall gentle his condition;" },
    { index: 4, text: "And gentlemen in England now a-bed" },
    { index: 5, text: "Shall think themselves accurs'd they were not here," },
    { index: 6, text: "And hold their manhoods cheap whiles any speaks" },
    { index: 7, text: "That fought with us upon Saint Crispin's day." }
];

function run() {
    // print "setting up callbacks..."
                
    for (var i = 0; i < items.length; i++) {
        doAsynchOperation(items[i], doOutput)
    }
    
    // print "setting up callbacks... done" <-- Callbacks cannot run until this line completes and run() is removed from the stack, leaving the thread available for other work
}

function doAsynchOperation(item, cb) {
    setTimeout(() => { // setTimeout is a convenient way to tell JS to run our doOutput asynchronously
        var words = item.text.split(" ");
        words[words.length - 1] = words[words.length - 1].toUpperCase();
        var obj = { text: words.join(" ") };
        item = Object.assign({}, item, obj);
        cb(item);
    }, Math.random() * 300);
}

function doOutput(item) {
    // print the item
}
</div>
            </div>
            <p>Next: <a href="ex2.html">Part 2</a></p>
        </div>
        <div id="output">
            <div id="content">
                
            </div>
        </div>
    </div>

    <script>
        var coll = document.getElementsByClassName("collapsible");
        var i;

        for (i = 0; i < coll.length; i++) {
            coll[i].addEventListener("click", function () {
                this.classList.toggle("active");
                var content = this.nextElementSibling;
                if (content.style.maxHeight) {
                    content.style.maxHeight = null;
                } else {
                    content.style.maxHeight = content.scrollHeight + "px";
                }
            });
        }
    </script>
</body>

</html>